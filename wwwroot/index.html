<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Photon</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <link href='https://fonts.googleapis.com/css?family=Amaranth' rel='stylesheet'>

    <script type="module">
        import { createApp, reactive } from '/petite-vue.js?module' // 'https://unpkg.com/petite-vue?module'

        const ms = 24 * 60 * 60 * 1000; //milliseconds in a day
        class Graphics {
            constructor(dateSeries = []) {
                this.dateSeries = dateSeries
                this.zoomFraction = 1.0
                this.plotPoints = dateSeries.length
                this.trueZero = false
                this.plot()
            }

            reset() {
                this.plotPath = "",
                    this.yCaptions = [],
                    this.xCaptions1 = [],
                    this.xCaptions2 = []
            }


            plot() {
                this.reset()
                if (this.dateSeries == null || this.dateSeries.length < 2) return

                const svgHeight = 30
                const svgWidth = 65

                let ds
                if (this.zoomFraction >= 1) {
                   ds = this.dateSeries
                } else {
                   ds = this.dateSeries.slice(Math.floor(this.dateSeries.length * (1 - this.zoomFraction)))
                  
                }
                this.plotPoints = ds.length;

                let daySeries = ds.map((p) => new Date(p.date) / ms);
                let valueSeries = ds.map((p) => p.value);
                let dayMin = Math.min.apply(Math, daySeries);
                let dayMax = Math.max.apply(Math, daySeries);
                let avg = mean(valueSeries)
                let sd = stdDev(valueSeries, avg)  //standard deviation
                let yMax = avg + sd * 4;
                let yMin = avg - sd * 3;

                if (this.trueZero || yMin < sd * 3) yMin = 0
                let dayRange = dayMax - dayMin;
                let xScale = svgWidth / dayRange;
                let yScale = svgHeight / (yMax - yMin);

                for (var i = 0; i < daySeries.length; i++) {
                    this.plotPath += toX(daySeries[i]) + "," + toY(valueSeries[i]) + " "
                }

                //y-axeis captions
                let yInterval = interval(yMax - yMin, 10.0);
                if (yInterval < 0 && yInterval > 0.01) {
                    // suppress more than 3 decimal places
                    yInterval = Math.round(yInterval * 100) / 100
                }

                for (let y = 0; y <= yMax; y += yInterval) {
                    if (y >= yMin) {
                        let yy = (y > 0.001) ? Math.round(y * 1000) / 1000 : y
                        this.yCaptions.push({ text: yy, y: toY(yy) });
                    }
                }

                // x axis captionns
                let dateMin = new Date(ds[0].date);
                let dateMax = new Date(ds[ds.length - 1].date);
                let yearMin = dateMin.getFullYear();
                let yearMax = dateMax.getFullYear();
                let yearRange = yearMax - yearMin;
                let monthRange = yearMax * 12 + dateMax.getMonth() - (yearMin * 12 + dateMin.getMonth());

                if (monthRange < 5) {
                    let incr = Math.floor(interval(dayRange, 14, [7, 2, 1]));
                    if (incr < 1) incr = 1;
                    let d = new Date(dateMin.getFullYear(), dateMin.getMonth())
                    let om = d.getMonth()
                    while (d < dateMax) {
                        let m = d.getMonth()
                        if (m != om) {
                            om = m
                            d = new Date(d.getFullYear(), m)
                            //this.xCaptions1.push({ text: "1", x: toX(d.getTime() / this.ms) });
                        } else {
                            this.xCaptions1.push({ text: d.getDate(), x: toX(d.getTime() / ms) });
                        }
                        d = new Date(d.getTime() + incr * ms);
                    }
                    this.xCaptions2 = monthCaptions({ month: "short", year: "numeric" });
                    if (
                        this.xCaptions2.length == 0 ||
                        this.xCaptions2[0].x > svgWidth / 5
                    ) {
                        this.xCaptions2.push({
                            text: dateMin.toLocaleDateString("default", { month: "short", year: "numeric" }), x: 0
                        });
                    }
                } else if (yearRange < 5) {
                    this.xCaptions1 = monthCaptions({ month: "short" });
                    this.xCaptions2 = yearCaptions();
                    if (
                        this.xCaptions2.length == 0 ||
                        this.xCaptions2[0].x > svgWidth / 5
                    ) {
                        this.xCaptions2.push({ text: yearMin, x: 0 });
                    }
                } else {
                    this.xCaptions1 = yearCaptions();
                }

                return this

                function monthCaptions(format) {
                    let capts = [];
                    if (monthRange > 0) {
                        let d = new Date(yearMin, 0);
                        let incr = Math.floor(interval(monthRange, 10, [12, 6, 3, 2, 1]));
                        if (incr < 1) incr = 1;
                        while (d < dateMax) {
                            if (d >= dateMin) {
                                capts.push({
                                    text: d.toLocaleDateString("default", format),
                                    x: toX(d.getTime() / ms),
                                });
                            }
                            let m = d.getMonth() + incr;
                            let y = d.getFullYear();
                            if (m > 12) {
                                y += Math.floor(m / 12);
                                m = m % 12;
                            }
                            d = new Date(y, m);
                        }
                    }
                    return capts;
                }

                function yearCaptions() {
                    let capts = [];
                    if (yearRange > 0) {
                        let incr = Math.floor(interval(yearRange, 10));
                        if (incr < 1) incr = 1;
                        let d = new Date(yearMin, 0);
                        while (d < dateMax) {
                            if (d >= dateMin) {
                                capts.push({ text: d.getFullYear(), x: toX(d.getTime() / ms) });
                            }
                            d = new Date(d.getFullYear() + incr, 0);
                        }
                    }
                    return capts;
                }

                function interval(range, steps, defaults = [10, 5, 2, 1]) {
                    var tempStep = range / steps;
                    var magPow = Math.pow(10.0, Math.floor(Math.log10(tempStep)));
                    var magMsd = Math.round(tempStep / magPow + 0.5);
                    for (var i = 0; i < defaults.length - 1; i++) {
                        if (magMsd > defaults[i + 1]) {
                            magMsd = defaults[i];
                            break;
                        }
                    }
                    return magMsd * magPow;

                }

                function toX(day) {
                    return (day - dayMin) * xScale;
                }

                function toY(val) {
                    return svgHeight - (val - yMin) * yScale;
                }

                function mean(arr) {
                    return arr.reduce((acc, val) => acc + val, 0) / arr.length;
                }

                function stdDev(arr, mean) {
                    return arr.reduce((acc, val) => acc + Math.abs(val - mean), 0) / arr.length;
                };
            }
        }


        const app = reactive({

            entityType: {},
            view: {},
            views: [],
            viewsPage: 0,
            viewSearch: '',
            indexType: {},
            indexTypePage: 0,
            indexes: [],
            indexesPage: 0,
            indexSearch: '',
            entityTypes: [],
            entityId: 0,
            values: [],
            idValues: [],
            page: 0,
            nPages: 0,
            userStarter: null,
            pwd: "",
            loginMessage: "",
            loadMessage: "",
            menu: { id: 0, name: "", menuItems: [] },
            menuHistory: [],
            row: 0,
            mode: 0,
            isAdvanced: false,
            isConfig: false,
            attributeConfig: { id: 0 },
            attributeUse: new attributeUse(),
            lookupsPage: 0,
            graphAttribute: null,
            graphData: new Graphics(),
            nextLookups() {
                this.lookupsPage++
                this.getLookups()
            },
            previousLookups() {
                this.lookupsPage--
                this.getLookups()
            },
            get viewStart() {
                return this.viewsPage * 19
            },
            get viewEnd() {
                return this.viewStart + 19;
            },
            // methods
            logout() {
                this.loginMessage = "";
                this.userStarter = null;
                this.menuHistory = [];
                this.mode = 0;
                this.pwd = "";
            },
            tryLogin() {
                let pwd = this.pwd
                if (pwd.length == 0) {
                    this.authenticated = false;
                    this.loginMessage = "You must enter a password";
                    return;
                }
                this.loginMessage = 'Checking password..'
                fetchWrapper
                    .post('login', { password: this.pwd })
                    .then((values) => {
                        if (values == null) {
                            this.loginMessage = 'Invalid password'
                        } else {
                            this.loginMessage = "Login succeeded. Loading..";
                            this.userStarter = values.userStarter
                            fetchWrapper.token = values.token
                            this.getEntityTypes();
                            resetLoginTimer()
                        }
                    })
                    .catch((error) => console.error(error));

            },
            getEntityTypes() {
                fetchWrapper
                    .get('EntityTypes')
                    .then(data => {
                        this.entityTypes = data
                        this.setEntityType(this.entityTypes.find(e => e.id == this.userStarter.entityTypeId))
                        this.goHome()
                    })
                    .catch((error) => console.log('error1' + error));
            },
            getLookups() {
                fetchWrapper
                    .get('Lookups/' + this.attributeConfig.id + ',' + this.lookupsPage + ',20')
                    .then(data => {
                        this.attributeConfig.lookups = data
                    })
                    .catch((error) => console.log('error1' + error));
            },
            setEntityType(entityType) {
                if (entityType !== this.entityType) {
                    this.entityType = entityType
                    this.setIndexType(this.entityType.indexTypes.find(t => t.id == this.entityType.defaultIndexTypeId))
                    this.viewsPage = 0;
                    this.indexesPage = 0;
                    this.indexTypePage = 0;
                    this.viewSearch = '';
                    this.indexSearch = '';
                    this.clear()
                    this.mode = 1
                    this.getIndexes()
                    this.getViews()
                }
            },
            setIndexType(indexType) {
                this.indexType = indexType
            },
            async getIndexes() {
                if (this.indexSearch.length >= 3) {
                    await fetchWrapper
                        .get('Indexes/' + this.indexType.id + ',' + this.indexesPage + ',19' + '/' + this.indexSearch)
                        .then((data) => {
                            this.indexes = data
                        })
                        .catch((error) => console.error(error));
                    if (indexTimer) {
                        clearTimeout(indexTimer)
                    }
                    indexTimer = setTimeout(() => {
                        this.indexesPage = 0;
                        this.indexSearch = ''
                        this.indexes = []
                    }, 100000);

                } else this.indexes = []
            },
            async nextIndex() {
                let index = this.indexes.find(i => i.entityId == this.entityId)
                let ix = this.indexes.indexOf(index)

                if (ix < this.indexes.length - 1) {
                    let newIndex = this.indexes[ix + 1]
                    this.setEntity(newIndex.entityId)
                } else if (ix == 18) {
                    await this.getIndexNextPage()
                    if (this.indexes.some(Boolean)) {
                        this.setEntity(this.indexes[0].entityId)
                    }
                }
            },
            async previousIndex() {
                let index = this.indexes.find(i => i.entityId == this.entityId)
                let ix = this.indexes.indexOf(index)

                if (ix > 0) {
                    let newIndex = this.indexes[ix - 1]
                    this.setEntity(newIndex.entityId)
                } else {
                    await this.getIndexPreviousPage()
                    if (this.indexes.some(Boolean)) {
                        this.setEntity(this.indexes[this.indexes.length - 1].entityId)
                    }
                }
            },
            async getIndexNextPage() {
                this.indexesPage++
                await this.getIndexes();
            },
            async getIndexPreviousPage() {
                this.indexesPage--
                await this.getIndexes();
            },
            nextPage() {
                if (this.page < this.nPages - 1) {
                    this.page++;
                    this.getMainValues()
                }
            },
            previousPage() {
                if (this.page > 0) {
                    this.page--;
                    this.getMainValues()
                }
            },
            graph(a) {
                if (this.isConfig) {
                    this.mode = 5
                    this.getAttributeConfig(a.attributeId)
                    this.getAttributeUse(a.attributeId)
                } else {
                    if (this.entityId > 0 && (a.dataTypeId == 2 || a.dataTypeId == 7)) {
                        this.getDatedValues(a)
                    }
                }
            },
            graphZoom(dir) {
                if (this.graphData && this.graphAttribute) {
                    let zf = this.graphData.zoomFraction
                    if (dir > 0 && zf <= 0.5) {
                        zf = zf * 2
                    }
                    else if (dir < 0 && this.graphData.plotPoints >= 4) {
                        zf = zf / 2
                    }
                    this.graphData.zoomFraction = zf
                    this.graphData.plot()
                }
            },
            async getDatedValues(a) {
                fetchWrapper
                    .get('DatedValues/' + this.entityId + ',' + a.attributeId)
                    .then((values) => {
                        this.dateValueSeries = values;
                        this.graphData = new Graphics(values)
                        this.graphAttribute = a
                    })
                    .catch((error) => console.error(error));
            },
            async getAttributeConfig(attributeId) {
                this.loadMessage = "loading.."
                fetchWrapper
                    .get('AttributeConfig/' + attributeId)
                    .then((data) => {
                        this.attributeConfig = data
                        this.lookupsPage = 0
                        this.loadMessage = null
                    })
                    .catch((error) => console.error(error));
            },

            async getAttributeUse(attributeId) {
                this.attributeUse = new attributeUse()
                fetchWrapper
                    .get('AttributeUse/' + attributeId)
                    .then((data) => {
                        this.attributeUse = data
                        this.loadMessage = null
                    })
                    .catch((error) => console.error(error));
            },
            async getMainValues() {
                fetchWrapper
                    .get('ViewValues/' + this.view.id + ',' + this.entityId + ',' + this.page)
                    .then((values) => this.values = values)
                    .catch((error) => console.error(error));
            },
            selectTargetClass(a) {
                if (this.isConfig) {
                    return a.attributeId == this.attributeConfig.id ? 'selected' : 'config'
                } else if (this.entityId > 0) {
                    return (a.dataTypeId == 2 || a.dataTypeId == 7) ? 'clickable' : 'hidden'
                }
                else return 'hidden'
            },
            selectTooltip(a) {
                if (this.isConfig) {
                    return 'click here to display config data for ' + a.name
                } else if (this.entityId > 0) {
                    return a.dataTypeId == 2 || a.dataTypeId == 7 ? 'click here to graph ' + a.name : null
                }
                return null
            },
            async getIdValues() {
                fetchWrapper
                    .get('ViewValues/' + this.entityType.idlineViewId + ',' + this.entityId + ',0')
                    .then((values) => this.idValues = values)
                    .catch((error) => console.error(error));
            },
            getViews() {
                let search = this.viewSearch
                this.viewsPage = 0;
                this.menuHistory = []

                if (typeof search === "string" && search.length > 0) {
                    this.views = this.entityType.views.filter(v => v.captions.some(c => c.text.toLowerCase().includes(search.toLowerCase())));

                    return;
                }
                this.views = this.entityType.views;

            },
            indexSearchChanged() {
                //debounce
                let timer = setTimeout(() => {
                    this.indexesPage = 0;
                    this.getIndexes();
                }, 500);
            },
            setView(view) {
                this.view = view
                this.graphAttribute = null
                this.page = 0
                if (this.view.isDated && this.menu.menuItems.length === 0) {
                    this.menu.menuItems.push({ "name": "Up screen", "function": "2", "seq": 1, "nextMenuId": 0, "startMenuId": 0 })
                    this.menu.menuItems.push({ "name": "Down screen", "function": "3", "seq": 2, "nextMenuId": 0, "startMenuId": 0 })
                }
                if (this.entityId > 0) {
                    this.getMainValues()
                    this.getNPages()
                }
            },
            setEntity(entityId) {
                this.entityId = entityId
                this.page = 0
                if (indexTimer) {
                    clearTimeout(indexTimer)
                }
                indexTimer = setTimeout(() => {
                    this.indexesPage = 0;
                    this.indexes = []
                    this.indexSearch = ''

                }, 10000);


                if (this.entityId > 0) {
                    this.getIdValues()
                    if (this.view.id > 0) {
                        if (this.graphAttribute) {
                            this.getDatedValues(this.graphAttribute)
                        } else {
                            this.getMainValues()
                            this.getNPages()
                        }
                        return
                    }
                }
            },
            getNPages() {
                fetchWrapper
                    .get('NPages/' + this.view.id + ',' + this.entityId)
                    .then((data) => this.nPages = data)
                    .catch((error) => console.error(error));
            },
            getMenu(id) {
                if (id != this.menu.id) {

                    if (id < 0) {
                        if (this.menuHistory.some(Boolean)) {
                            this.menu = this.menuHistory.pop()
                        } else {
                            this.goHome()
                        }
                        return
                    }

                    let lastMenu = this.menuHistory.some(Boolean) ? this.menuHistory[this.menuHistory.length - 1] : null;

                    if (lastMenu == null ||
                        lastMenu.id !== this.menu.id
                    ) {
                        this.menuHistory.push(this.menu)
                    }

                    fetchWrapper
                        .get('Menu/' + id)
                        .then((data) => {
                            if (data.menuItems.length === 0) {
                                data.menuItems.push({ "name": "Prev. menu", "function": "", "seq": 3, "nextMenuId": -2, "startMenuId": 0 })
                                if (this.view.isDated) {
                                    data.menuItems.push({ "name": "Up screen", "function": "2", "seq": 1, "nextMenuId": 0, "startMenuId": 0 })
                                    data.menuItems.push({ "name": "Down screen", "function": "3", "seq": 2, "nextMenuId": 0, "startMenuId": 0 })
                                }
                            }
                            this.menu = data
                        })
                        .catch((error) => console.error(error));
                }
            },
            goHome() {
                this.menu = this.userStarter.menu;
                this.menuHistory = []
                this.setEntityType(this.entityTypes.find(t => t.id == this.userStarter.entityTypeId))
                this.setIndexType(this.entityType.indexTypes.find(t => t.id == this.userStarter.indexTypeId))
                this.mode = 1
                this.viewSearch = ""
                this.isAdvanced = false
                this.graphAttribute = null
            },
            doMenuItem(item) {
                item.isSelected = true
                let timer = setTimeout(() => {
                    item.isSelected = false
                }, 500);
                switch (item.function) {
                    case 'SCRN':
                        this.setView(this.entityType.views.find(v => v.id == item.parameter1))
                        break;
                    case 'CHGE':
                        this.setEntityType(this.entityTypes.find(e => e.id == item.parameter1))
                        break;
                    case '1':
                        let page = window.prompt('go to page:')
                        if (page > 0 && page <= this.nPages) {
                            this.page = page - 1
                        }
                        break;

                    case '2':
                        this.previousPage()
                        break;

                    case '3':
                        this.nextPage()
                        break;
                    default:
                    // code block
                }
                if (item.nextMenuId !== 0) {
                    this.getMenu(item.nextMenuId)
                } else if (item.startMenuId !== 0) {
                    this.getMenu(item.startMenuId)
                }
            },
            setAdvanced() {
                if (!this.isAdvanced) {
                    this.isAdvanced = true
                    this.menu = JSON.parse('{ "id":0, "name":"ADVANCED","menuItems":[]}')
                    this.mode = 2
                    this.getViews()
                    if (this.view.isDated && this.menu.menuItems.length === 0) {
                        this.menu.menuItems.push({ "name": "Up screen", "function": "2", "seq": 1, "nextMenuId": 0, "startMenuId": 0 })
                        this.menu.menuItems.push({ "name": "Down screen", "function": "3", "seq": 2, "nextMenuId": 0, "startMenuId": 0 })
                    }
                }
            },
            clear() {
                this.view = {}
                this.idValues = []
                this.values = []
            },
            keydown(e) {
                switch (e.key) {
                    case "Escape":
                        this.logout()
                        break
                    case "ArrowUp":
                        this.previousIndex()
                        return;
                    case "ArrowDown":
                        this.nextIndex()
                        return;
                    case "PageUp":
                        this.previousPage()
                        return;
                    case "PageDown":
                        this.nextPage()
                        return;
                    case "Enter":
                        if (this.mode > 1) this.goHome()
                        return;
                    case "HOME":
                        this.goHome()
                        return
                    case "0":
                        let timer = setTimeout(() => {
                            document.getElementById("#searchEntity").focus();
                        }, 500);
                        this.mode = 1
                        return
                    default:
                }

                if (Number.isNaN(e.key)) return
                let keyMap = [6, 7, 8, 3, 4, 5, 0, 1, 2]
                let menuId = keyMap[e.key - 1]
                if (menuId === undefined) return
                let menuItem = this.menu.menuItems.find(i => i.seq == menuId)
                if (menuItem === undefined) {
                    return;
                }
                if (menuItem !== null) {

                    //document.getElementById("#searchEntity").blur();
                    this.doMenuItem(menuItem)
                }
            },
            viewCaption(text) {
                if (this.viewSearch.length > 0) {
                    let reg = new RegExp(`${this.viewSearch}`, 'gi');

                    return text.replace(reg, "<tspan>$&</tspan>")
                }
                return text
            }

        })

        createApp({ app }).mount()

        var indexTimer
        var loginTimer

        function resetLoginTimer() {

            if (loginTimer) {
                clearTimeout(loginTimer)
            }
            loginTimer = setTimeout(() => {
                app.logout()
                location.reload();
            }, 900000);
        }

        class FetchWrapper {
            constructor(baseUrl) {
                this.baseUrl = baseUrl;
                this.token = null;
            }

            async get(url) {
                if (this.token == null) return;
                resetLoginTimer()
                const response = await fetch(`${this.baseUrl}${url}`,
                    {
                        method: 'get',
                        headers: {
                            'Accept': 'application/json, text/plain, */*',
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + this.token,
                        }
                    });
                this.status = response.status;
                if (!response.ok) {
                    throw new Error("Network response was not ok");
                }
                return response.json();
            }


            async put(url, data) {
                const response = await fetch(`${this.baseUrl}${url}`, {
                    method: 'PUT',
                    body: JSON.stringify(data),
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
                if (!response.ok) {
                    console.log(response.status);
                }
                return response.json();
            }

            async post(url, data) {
                const response = await fetch(`${this.baseUrl}${url}`, {
                    method: 'POST',
                    body: JSON.stringify(data),
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
                if (!response.ok) {
                    console.log(response.status);
                    return;
                }
                resetLoginTimer()
                return response.json();
            }

            async delete(url) {
                const response = await fetch(`${this.baseUrl}${url}`, {
                    method: 'DELETE',
                });
                return response.json();
            }
        }

        const fetchWrapper = new FetchWrapper(window.location);

        function attributeUse() {
            this.nEntities = "..."
            this.perEntity = "..."
            this.latest = "..."
        }

    </script>
</head>

<body v-scope="app" @keydown="keydown">

    <!--The tools view  -->
    <svg viewBox="0 0 160 480" class="nav" preserveAspectRatio="none" v-if="mode>0"
         font-size="16.6666666">

        <line x1="160" y1="0" x2="160" y2="480"></line>

        <!--select entity  -->
        <g v-show="mode==1">
            <text class="caption" x="10" y="20">Select {{entityType.name}}</text>

            <foreignObject x="10" y="30" width="180" height="30">
                <input type="text" v-model="indexSearch" width="170" autocomplete="off"
                       @keyup.self="indexSearchChanged" @input="indexSearchChanged"
                       :placeholder="indexType.name" id="#searchEntity" />
            </foreignObject>

            <text v-for="(i, ix) in indexes" class="input"
                  x="10" :y="ix*20 + 80" v-bind:class="[(i.entityId == entityId) ? 'selected' : 'input']"
                  @click="setEntity(i.entityId)">{{i.term}}</text>

            <text class="caption clickable" @click="getIndexPreviousPage" x="10" y="470" v-show="indexesPage>0">&lt;BACK</text>
            <text class="caption clickable" @click="getIndexNextPage" x="110" y="470" v-show="indexes.length==19">NEXT&gt;</text>

        </g>

        <!--select view  -->
        <g v-show="mode==2">

            <text class="caption" x="10" y="20">Select view</text>

            <foreignObject x="10" y="30" width="180" height="30">
                <input type="text" v-model="viewSearch" @keyup="getViews"
                       @input.self="getViews" width="170" autocomplete="off" placeholder="enter text" />
            </foreignObject>
            <text v-for="(v, ix) in views.slice(viewStart, viewEnd)" class="input"
                  x="10" :y="ix*20+80" v-bind:class="[(v == view) ? 'selected' : 'input']"
                  @click="setView(v)">
                {{v.name}}
            </text>
            <text class="caption clickable" @click="viewsPage--" x="10" y="470" v-show="viewsPage>0">&lt;BACK</text>
            <text class="caption clickable" @click="viewsPage++" x="110" y="470" v-show="(viewEnd<views.length)">NEXT&gt;</text>
        </g>

        <g v-show="mode==3">

            <text class="caption" x="10" y="20">Select entity type</text>

            <text v-for="(t, index) in entityTypes" class="input"
                  x="10" :y="index*20 + 60" v-bind:class="[(t.id == entityType.id) ? 'selected' : 'input']"
                  @click="setEntityType(t)">{{t.name}}</text>

        </g>

        <g v-show="mode==4">

            <text class="caption" x="10" y="20">Select index type</text>

            <text v-for="(t, ix) in entityType.indexTypes.slice(indexTypePage * 19 , indexTypePage * 19 + 19)"
                  x="1" :y="ix*20 + 60" v-bind:class="[(t == indexType) ? 'selected' : 'input']"
                  @click="setIndexType(t)">{{t.name}}</text>

            <text class="caption clickable" @click="indexTypePage--" x="10" y="470" v-show="indexTypePage>0">&lt;BACK</text>
            <text class="caption clickable" @click="indexTypePage++" x="110" y="470" v-show="(indexTypePage * 19 + 19 ) < entityType.indexTypes.length">NEXT&gt;</text>

        </g>

        <!--attribute config view  -->
        <g v-show="mode==5" font-size="12">
            <g v-show="loadMessage">
                <text>{{loadMessage}}</text>
            </g>
            <g v-else>
                <text class="caption" x="2" y="20">View ID: {{view.id}}</text>
                <text class="caption" x="2" y="35">Attribute: {{attributeConfig.id}}: {{attributeConfig.name}}</text>
                <text class="caption" x="2" y="50">{{attributeConfig.comment}}</text>
                <text class="caption" x="2" y="65">max: {{attributeConfig.max}} min: {{attributeConfig.min}}</text>
                <text class="caption" x="2" y="80">{{entityType.name}}s: {{attributeUse.nEntities}}</text>
                <text class="caption" x="2" y="95">Per {{entityType.name}}: {{attributeUse.perEntity}}</text>
                <text class="caption" x="2" y="110">Most recent: {{attributeUse.latest}}</text>
                <text class="caption" x="2" y="125">Type: {{attributeConfig.dataType}}</text>

                <text class="caption" x="2" y="140" v-show="attributeConfig.quark">Quark: {{attributeConfig.quark}}</text>

                <g v-show="attributeConfig.lookups.length > 0">
                    <text class="caption" x="2" y="140">Lookup type:</text>
                    <text class="caption" x="2" y="155">{{attributeConfig.lookupType}}</text>
                    <text v-for="(l ,ix) in attributeConfig.lookups" class="value" x="2" :y="170+ix*15">{{l.name}}</text>

                    <text class="caption clickable" @click="previousLookups" x="10" y="470" v-show="lookupsPage>0">&lt;BACK</text>
                    <text class="caption clickable" @click="nextLookups" x="110" y="470" v-show="attributeConfig.lookups.length==20">NEXT&gt;</text>

                </g>


            </g>
        </g>
    </svg>

    <!--The main view. reprersenting a 5:3 aspect rato. 80 caracters wide
        24 lines of characters, double line spacing = 48 characters high
        monospace font also has 5:3 aspect ratio (1.6666)
        set font size 1.66666 so character width=1/80 screen width  -->

    <svg viewBox="0 0 80 48" class="main" preserveAspectRatio="none"
         font-size="1.6666666" v-if="mode>0">
        <line x1="0" y1="3" x2="80" y2="3"></line>
        <line x1="0" y1="41" x2="80" y2="41"></line>
        <line x1="40" y1="41" x2="40" y2="48"></line>
        <line x1="0" y1="0" x2="0" y2="48"></line>
        <text class="value" v-for="v in idValues" :x="v.x" :y="(v.y-3)*2">{{v.text}}</text>
        
        <g v-show="!graphAttribute">
            <!--Tabular area-->
            <text class="caption" v-for="c in view.captions" :x="c.x" :y="c.y*2" v-html="viewCaption(c.text)"></text>
            <text class="value" v-for="v in values" :x="v.x" :y="v.y*2">{{v.text}}</text>
            <rect v-for="a in view.viewAttributes" :height="(view.nRows) * 2 - 0.33333" :width="a.displayLength"
                  :class="selectTargetClass(a)"
                  :x="a.x" :y="(a.y)*2-1.33333 " @click="graph(a)">
               <title>{{selectTooltip(a)}}</title>
            </rect> />
            <text v-show="nPages>1" class="value" x="26" y="43">{{page + 1}}/{{nPages}}</text>
            <text class="caption" x="1" y="43">{{menu.name}}</text>
            <text :class="[i.isSelected? 'selected': 'input']" v-for="i in menu.menuItems"
                  :y="Math.floor(i.seq / 3) * 2 + 43"
                  :x="(i.seq % 3) * 13 + 41" @click="doMenuItem(i)">{{i.name}}</text>
        </g>
        <g v-show="graphAttribute">
            <!-- graph area -->
            <svg x="0" y="3" width="80" height="38"
                 viewBox="0 0 80 34" preserveAspectRatio="none" class="outer" >
                <g v-show="graphData.plotPath.trim() != ''">
                    <rect width="100%" height="100%" class="outer" />
                    <!-- plot area -->
                    <svg viewBox="0 0 65 30" x="10" y="0" height="30" width="65"
                         class="plotArea" preserveAspectRatio="none">
                        <rect width="100%" height="100%" class="plotArea" />
                        <polyline :points="graphData.plotPath" />
                        <!-- gridlines -->
                        <line v-for="c in graphData.xCaptions1" y1="0" y2="34" :x1="c.x" :x2="c.x" class="grid"></line>
                        <line v-for="c in graphData.yCaptions" :y1="c.y" :y2="c.y" x1="0" x2="70" class="grid"></line>
                    </svg>
                    <!-- Y scale -->
                    <svg x="0" y="0" height="30" width="10" viewBox="0 0 10 30" class="axis" preserveAspectRatio="none">
                        <text text-anchor="end" v-for="c in graphData.yCaptions" :y="c.y" x="9.8" class="axis">
                            {{c.text}}
                        </text>
                    </svg>
                    <!-- X scale -->
                    <svg x="10" y="30" width="75" height="4" viewBox="0 0 75 4" class="axis" preserveAspectRatio="none">
                        <line v-for="c in graphData.xCaptions2" y1="0" y2="4" :x1="c.x" :x2="c.x" class="grid"></line>
                        <text v-for="c2 in graphData.xCaptions2" y="3.6" :x="c2.x" class="axis">
                            {{c2.text}}
                        </text>
                        <text v-for="c1 in graphData.xCaptions1" y="1.6" :x="c1.x" class="axis">
                            {{c1.text}}
                        </text>
                    </svg>
                </g>
                <g v-show="graphData.plotPath.trim() == ''">
                    <text class="axis" x="37" y="20"> No data</text>
                </g>
            </svg>
            <text class="caption" x="41" y="43">Graphing {{graphAttribute.name}}</text>
            <text v-show="graphData.zoomFraction < 1" class="input" x="41" y="45" @click="graphZoom(1)">Zoom out</text>
            <text v-show="graphData.zoomFraction > 0" class="input" x="54" y="45" @click="graphZoom(-1)">Zoom in</text>
            <text class="input" x="67" y="47" @click="graphAttribute=null">Finished</text>
        </g>
        <g v-show="isAdvanced">
            <text :class="[(mode==1)? 'selected': 'input']" x="1" y="45" @click="mode=1">Select by {{indexType.name}}</text>
            <text :class="[(mode==2)? 'selected': 'input']" x="1" y="47" @click="mode=2">View</text>
            <text :class="[(mode==3)? 'selected': 'input']" x="17" y="47" @click="mode=3">Entity</text>
            <text :class="[(mode==4)? 'selected': 'input']" x="33" y="47" @click="mode=4">Index</text>
            <g @click="isConfig=!isConfig" class="clickable">
                <svg viewBox="0 0 100 100" x="17" y="41.9" width="1.2" height="1.2">

                    <rect x="0" y="0" height="100" width="100" fill="white" stroke="black" stroke-width="5" />
                    <polyline v-show="isConfig" points="0,50 40,100 100,0"
                                style="fill:none;stroke:red;stroke-width:20" />
                </svg>
                <text x="19" y="43" :class="[(isConfig)? 'selected': 'input']">config</text>
            </g>

        </g>
        <text class="input" x="33" y="43" @click="logout">Logout</text>
        <text :class="[!isAdvanced? 'caption clickable': 'input']" x="33" y="45" @click="goHome">Home</text>



        <text v-show="!isAdvanced" class="input" x="1" y="47" @click="setAdvanced">Advanced</text>

    </svg>

    <!-- log in -->
    <svg v-if="mode==0" viewBox="0 0 960 480" class="login" preserveAspectRatio="none"
         font-size="17">
        <text x="20" y="60" class="caption">Proton password:</text>
        <foreignObject x="170" y="40" width="180" height="30">
            <input type="password" v-model="pwd" width="170" autocomplete="off" @keydown.enter="tryLogin" />
        </foreignObject>
        <g @click="tryLogin">
            <rect x="360" y="40" width="100" height="30" class="button" fill="white" />
            <text x="380" y="60" class="button">submit</text>
        </g>
        <text class="caption" x="20" y="100">{{loginMessage}}</text>
    </svg>

    <style>
        line.grid {
            stroke-width: 0.1;
            stroke: grey;
        }

        svg.outer {
            background-color: navy;
        }

        text.axis {
            fill: white;
            font-size: 1.6666;
        }

        svg polyline {
            stroke-width: 0.2;
            fill: none;
            stroke: red;
        }

        rect.outer {
            fill: navy;
        }

        rect.plotArea {
            fill: hsl(from navy h s calc(l + 10));
            stroke: white;
            stroke-width: 0.2;
        }
        svg {
            height: 100vh;
            display: block;
            font-family: Fira Code, monospace;
        }

        tspan {
            fill: palevioletred;
            font-weight: bold;
            text-decoration: underline;
        }

        svg.nav {
            width: 20%;
            float: left;
            background-color: midnightblue;
        }

        svg.main {
            width: 80%;
            float: right;
            background-color: navy;
        }

        svg.login {
            width: 100%;
            float: right;
            background-color: navy;
        }

        line {
            stroke: grey;
            stroke-width: 0.1;
        }

        text.value {
            fill: white;
        }

        text.input {
            fill: grey;
            cursor: pointer;
        }

        rect.config {
            opacity: 0.2;
            fill: aqua;
            cursor: pointer;
        }

        rect.selected {
            opacity: 0.2;
            fill: red;
            cursor: pointer;
        }

        rect.hidden {
            opacity: 0;
        }

        rect.clickable {
            opacity: 0;
            cursor: pointer;
        }

        .clickable {
            cursor: pointer;
        }

        rect.button {
            fill: lightgray;
            stroke: black;
            stroke-width: 4px;
            cursor: pointer;
        }

        text.clickable {
            cursor: pointer;
        }

        text.button {
            cursor: pointer;
            fill: black;
        }

        text.selected {
            fill: yellow;
        }

        text.caption {
            fill: yellow;
        }

        [contenteditable] {
            outline: 0px solid transparent;
        }

        input {
            outline: 0px solid transparent;
        }

        p.input {
            background-color: white;
        }

    </style>
</body>
</html>